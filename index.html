
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Echo Drift - Circular Movement</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: black;
      font-family: 'Orbitron', sans-serif;
    }
    canvas {
      display: block;
      background: radial-gradient(circle at center, #111 0%, #000 100%);
    }
    #ui {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      color: #0ff; text-align: center; z-index: 10;
    }
    .mobile-controls {
      position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 10;
    }
    .mobile-controls button {
      width: 60px; height: 60px; margin: 10px; font-size: 24px;
      background: #111; color: #0ff; border: 2px solid #0ff; border-radius: 50%;
      transition: transform 0.1s, background 0.2s;
    }
    .mobile-controls button:active {
      background: #0ff; color: #000;
      transform: scale(1.2);
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
</head>
<body>
  <div id="ui">
    <h1>Echo Drift</h1>
    <button onclick="startGame()">Start Game</button>
    <p id="lapInfo">Lap: 1/5</p>
  </div>
  <div class="mobile-controls">
    <button ontouchstart="keys['ArrowLeft']=true" ontouchend="keys['ArrowLeft']=false">←</button>
    <button ontouchstart="keys['ArrowUp']=true" ontouchend="keys['ArrowUp']=false">↑</button>
    <button ontouchstart="keys['ArrowRight']=true" ontouchend="keys['ArrowRight']=false">→</button>
  </div>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let keys = {};
    let frame = 0;
    let running = false;
    let lap = 1;
    let playerPath = [];
    let ghosts = [];

    const center = () => ({ x: canvas.width / 2, y: canvas.height / 2 });
    const trackRadius = () => Math.min(canvas.width, canvas.height) / 3;

    let player = {
      angle: 0, speed: 0, radius: trackRadius(), angularVelocity: 0,
      shield: false, shieldTimer: 0, color: "#0ff"
    };

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      player.radius = trackRadius();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    window.addEventListener("keydown", e => keys[e.key] = true);
    window.addEventListener("keyup", e => keys[e.key] = false);

    function startGame() {
      document.getElementById("ui").style.display = "none";
      running = true;
      requestAnimationFrame(gameLoop);
    }

    function updatePlayer() {
      if (keys["ArrowLeft"]) player.angularVelocity -= 0.0015;
      if (keys["ArrowRight"]) player.angularVelocity += 0.0015;
      if (keys["ArrowUp"]) player.speed = Math.min(player.speed + 0.02, 3);
      else player.speed *= 0.98;

      player.angularVelocity *= 0.98;
      player.angle += player.angularVelocity;

      // Simulate circular velocity (convert to x/y)
      let x = center().x + player.radius * Math.cos(player.angle);
      let y = center().y + player.radius * Math.sin(player.angle);
      let dx = -Math.sin(player.angle) * player.speed;
      let dy = Math.cos(player.angle) * player.speed;

      x += dx;
      y += dy;

      // Adjust radial position back toward circle
      let distFromCenter = Math.hypot(x - center().x, y - center().y);
      let radialDiff = distFromCenter - trackRadius();
      let pull = -radialDiff * 0.05;
      let toCenterAngle = Math.atan2(y - center().y, x - center().x);
      x += Math.cos(toCenterAngle) * pull;
      y += Math.sin(toCenterAngle) * pull;

      // Recalculate radius and angle
      player.radius = Math.hypot(x - center().x, y - center().y);
      player.angle = Math.atan2(y - center().y, x - center().x);

      playerPath.push({x, y, angle: player.angle});

      // Ghost collision
      for (let g of ghosts) {
        let ghostPos = g[frame];
        if (ghostPos && Math.hypot(x - ghostPos.x, y - ghostPos.y) < 15) {
          running = false;
          alert("Crashed into your echo!");
        }
      }

      // Lap check
      if (
        x > center().x + trackRadius() - 10 &&
        x < center().x + trackRadius() + 10 &&
        y > center().y - 20 &&
        y < center().y + 20
      ) {
        ghosts.push([...playerPath]);
        playerPath = [];
        lap++;
        if (lap > 5) {
          running = false;
          alert("Victory! All 5 laps complete.");
        }
        document.getElementById("lapInfo").innerText = "Lap: " + lap + "/5";
      }

      player._x = x;
      player._y = y;
    }

    function drawTrack() {
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(center().x, center().y, trackRadius(), 0, Math.PI * 2);
      ctx.stroke();

      for (let i = 0; i < 360; i += 20) {
        let a = i * Math.PI / 180;
        let x = center().x + trackRadius() * Math.cos(a);
        let y = center().y + trackRadius() * Math.sin(a);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(a) * 10, y + Math.sin(a) * 10);
        ctx.strokeStyle = "#0ff";
        ctx.stroke();
      }

      // Start line
      ctx.strokeStyle = "#ff0";
      ctx.beginPath();
      ctx.moveTo(center().x + trackRadius(), center().y - 20);
      ctx.lineTo(center().x + trackRadius(), center().y + 20);
      ctx.stroke();
    }

    function drawPlayer(p, ghost = false) {
      ctx.save();
      ctx.translate(p._x, p._y);
      ctx.rotate(p.angle || 0);
      ctx.fillStyle = ghost ? "rgba(255,0,255,0.3)" : p.color;
      ctx.shadowBlur = ghost ? 0 : 15;
      ctx.shadowColor = p.color;
      ctx.beginPath();
      ctx.moveTo(0, -10);
      ctx.lineTo(6, 10);
      ctx.lineTo(-6, 10);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawGhosts() {
      for (let g of ghosts) {
        if (g[frame]) drawPlayer({_x: g[frame].x, _y: g[frame].y, angle: g[frame].angle}, true);
      }
    }

    function gameLoop() {
      if (!running) return;
      frame++;
      updatePlayer();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTrack();
      drawGhosts();
      drawPlayer(player);
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
